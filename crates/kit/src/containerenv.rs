//! Helpers for parsing the `/run/.containerenv` file generated by podman.

use std::io::{BufRead, BufReader};
use std::sync::{Arc, OnceLock};

use anyhow::Result;
use cap_std_ext::cap_std;
use cap_std_ext::cap_std::fs::Dir;
use cap_std_ext::prelude::CapStdExtDirExt;
use fn_error_context::context;

/// Path is relative to container rootfs (assumed to be /)
pub(crate) const PATH: &str = "run/.containerenv";

#[derive(Debug, Default)]
pub(crate) struct ContainerExecutionInfo {
    pub(crate) engine: String,
    pub(crate) name: String,
    pub(crate) id: String,
    pub(crate) image: String,
    pub(crate) imageid: String,
    pub(crate) rootless: Option<String>,
}

/// Load and parse the `/run/.containerenv` file.
#[context("Querying container")]
pub(crate) fn get_container_execution_info(rootfs: &Dir) -> Result<ContainerExecutionInfo> {
    let f = match rootfs.open_optional(PATH)? {
        Some(f) => BufReader::new(f),
        None => {
            anyhow::bail!(
                "This command must be executed inside a podman container (missing /{PATH})"
            )
        }
    };
    let mut r = ContainerExecutionInfo::default();
    for line in f.lines() {
        let line = line?;
        let line = line.trim();
        let Some((k, v)) = line.split_once('=') else {
            continue;
        };
        // Assuming there's no quotes here
        let v = v.trim_start_matches('"').trim_end_matches('"');
        match k {
            "engine" => r.engine = v.to_string(),
            "name" => r.name = v.to_string(),
            "id" => r.id = v.to_string(),
            "image" => r.image = v.to_string(),
            "imageid" => r.imageid = v.to_string(),
            "rootless" => r.rootless = Some(v.to_string()),
            _ => {}
        }
    }
    Ok(r)
}

/// Return information for the container environment
pub(crate) fn get_cached_container_execution_info(rootfs: &Dir) -> Result<&ContainerExecutionInfo> {
    static INFO: std::sync::OnceLock<ContainerExecutionInfo> = std::sync::OnceLock::new();
    if let Some(r) = INFO.get() {
        return Ok(r);
    }
    let r = get_container_execution_info(rootfs)?;
    // Discard duplicate init attempts
    let _ = INFO.set(r);
    // SAFETY: We know this was initialized
    Ok(INFO.get().unwrap())
}

/// Return a cached copy of the global rootfs
pub(crate) fn global_rootfs(authority: cap_std::AmbientAuthority) -> Result<Arc<Dir>> {
    static ROOTFS: OnceLock<Arc<Dir>> = OnceLock::new();
    if let Some(r) = ROOTFS.get() {
        return Ok(r.clone());
    }
    let r = Dir::open_ambient_dir("/", authority)?;
    let _ = ROOTFS.set(Arc::new(r));
    Ok(ROOTFS.get().unwrap().clone())
}
